#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <iec61850_common.h>
#include <mms_client_connection.h>
#include <iso_connection_parameters.h>

/* ==================== Utility: Zeek printing helpers ==================== */

static void zeek_fputs_escaped(FILE* f, const char* s)
{
    fputc('"', f);
    for (const unsigned char* p=(const unsigned char*)s; *p; ++p) {
        if (*p == '"' || *p == '\\') {
            fputc('\\', f);
            fputc(*p, f);
        } else if (*p == '\n') {
            fputc('\\', f); fputc('n', f);
        } else if (*p == '\r') {
            fputc('\\', f); fputc('r', f);
        } else if (*p == '\t') {
            fputc('\\', f); fputc('t', f);
        } else {
            fputc(*p, f);
        }
    }
    fputc('"', f);
}

static void zeek_write_header(FILE* zf,
                              const char* vendor,
                              const char* model,
                              const char* revision,
                              const char* tase2_version_str)
{
    fprintf(zf,
        "# THIS FILE IS GENERATED BY explore-mms.\n"
        "# Do not edit manually.\n\n"
        "module tase2;\n\n"
        "export {\n"
        "  # Log-ID registrieren\n"
        "  redef enum Log::ID += { MMS_VARS_LOG };\n\n"
        "  # Log-Datensatz für MMS-Variablenwerte\n"
        "  type VarsLog: record {\n"
        "    ts: time &log;\n"
        "    id: conn_id &log;\n"
        "    uid: string &log &optional;\n"
        "    op: string &log;        # genutzte MMS-Operation (read, write, report)\n"
        "    direction: string &log; # rsp=Read-Response, rpt=InformationReport, wrt=Write-Response\n"
        "    domain: string &log;\n"
        "    name: string &log;      # Item/Variable innerhalb der Domäne\n"
        "    obj: string &log;       # domain.name\n"
        "    flat_type: string &log; # TASE2-Flat-Type (Real, Unsigned, Bool, Discrete_Or_State, String, unknown)\n"
        "    mms_type: string &log;  # Haupt-MMS-Typ (MMS_FLOAT, MMS_INTEGER, ...)\n"
        "    value: string &log &optional;\n"
        "    error: string &log &optional;\n"
        "  };\n"
        "}\n\n"
        "# Server-Metadaten (aus explore-mms)\n"
        "const server_vendor = ");
    zeek_fputs_escaped(zf, vendor ? vendor : "");
    fprintf(zf, ";\nconst server_model = ");
    zeek_fputs_escaped(zf, model ? model : "");
    fprintf(zf, ";\nconst server_revision = ");
    zeek_fputs_escaped(zf, revision ? revision : "");
    fprintf(zf, ";\nconst tase2_version = ");
    zeek_fputs_escaped(zf, tase2_version_str ? tase2_version_str : "");
    fprintf(zf, ";\n\n");

    fprintf(zf,
        "# Beispielhafte, generierte Variablen-Metadaten\n"
        "# Schlüssel = \"DOMAIN.ITEM\"\n"
        "type VarMeta: record {\n"
        "  domain: string;\n"
        "  item: string;\n"
        "  flat_type: string;\n"
        "  mms_type: string;\n"
        "};\n\n");

    fprintf(zf, "const mms_variables: table[string] of VarMeta = {\n");
}

static void zeek_write_var_entry(FILE* zf,
                                 const char* domain,
                                 const char* item,
                                 const char* flat_type,
                                 const char* mms_type,
                                 int* first_entry)
{
    if (!(*first_entry))
        fprintf(zf, ",\n");
    *first_entry = 0;

    /* key: ["DOMAIN.ITEM"] = [$domain="DOMAIN", $item="ITEM", $flat_type="...", $mms_type="..."] */
    fprintf(zf, "  [");
    /* key string */
    {
        char keybuf[2048];
        keybuf[0] = '\0';
        if (domain && item) {
            size_t dn = strlen(domain), in = strlen(item);
            if (dn + in + 2 < sizeof(keybuf)) {
                strcpy(keybuf, domain);
                strcat(keybuf, ".");
                strcat(keybuf, item);
            } else {
                strncpy(keybuf, "<name-too-long>", sizeof(keybuf)-1);
                keybuf[sizeof(keybuf)-1] = '\0';
            }
        } else {
            strncpy(keybuf, "<unknown>", sizeof(keybuf)-1);
            keybuf[sizeof(keybuf)-1] = '\0';
        }
        zeek_fputs_escaped(zf, keybuf);
    }
    fprintf(zf, "] = [$domain=");
    zeek_fputs_escaped(zf, domain ? domain : "");
    fprintf(zf, ", $item=");
    zeek_fputs_escaped(zf, item ? item : "");
    fprintf(zf, ", $flat_type=");
    zeek_fputs_escaped(zf, flat_type ? flat_type : "unknown");
    fprintf(zf, ", $mms_type=");
    zeek_fputs_escaped(zf, mms_type ? mms_type : "UNKNOWN");
    fprintf(zf, "]");
}

static void zeek_write_known_vars_head(FILE* zf)
{
    fprintf(zf, "\n};\n\nconst known_vars: set[string] = set(\n");
}

static void zeek_write_known_var(FILE* zf, const char* domain, const char* item, int* first)
{
    if (!(*first))
        fprintf(zf, ",\n");
    *first = 0;

    char keybuf[2048];
    keybuf[0] = '\0';
    if (domain && item) {
        size_t dn = strlen(domain), in = strlen(item);
        if (dn + in + 2 < sizeof(keybuf)) {
            strcpy(keybuf, domain);
            strcat(keybuf, ".");
            strcat(keybuf, item);
        } else {
            strncpy(keybuf, "<name-too-long>", sizeof(keybuf)-1);
            keybuf[sizeof(keybuf)-1] = '\0';
        }
    } else {
        strncpy(keybuf, "<unknown>", sizeof(keybuf)-1);
        keybuf[sizeof(keybuf)-1] = '\0';
    }
    fprintf(zf, "  ");
    zeek_fputs_escaped(zf, keybuf);
}

static void zeek_write_tail(FILE* zf)
{
    fprintf(zf, "\n);\n\n");

    /* helper functions and event handlers */
    fprintf(zf, "%s",
        "# Hilfsfunktion: ObjectName -> \"DOMAIN.ITEM\" oder Alternativen\n"
        "function obj_name_to_key(n: mms::ObjectName): string\n"
        "  {\n"
        "  if ( n?$domain_specific )\n"
        "    return fmt(\"%s.%s\", n$domain_specific$domainId, n$domain_specific$itemId);\n"
        "  if ( n?$vmd_specific )\n"
        "    return fmt(\"VMD.%s\", n$vmd_specific);\n"
        "  if ( n?$aa_specific )\n"
        "    return fmt(\"AA.%s\", n$aa_specific);\n"
        "  return \"<unknown>\";\n"
        "  }\n\n"
        "# Hilfsfunktion: Data -> string (vereinfachtes, generisches Flattening)\n"
        "function data_to_str(d: mms::Data): string\n"
        "  {\n"
        "  if ( d?$integer )        return fmt(\"%d\", d$integer);\n"
        "  if ( d?$unsigned )       return fmt(\"%d\", d$unsigned);\n"
        "  if ( d?$boolean )        return d$boolean ? \"true\" : \"false\";\n"
        "  if ( d?$floating_point ) return d$floating_point;\n"
        "  if ( d?$visible_string ) return d$visible_string;\n"
        "  if ( d?$mMSString )      return d$mMSString;\n"
        "  if ( d?$bit_string )     return d$bit_string;\n"
        "  if ( d?$octet_string )   return d$octet_string;\n"
        "  if ( d?$utc_time )       return d$utc_time;\n"
        "  if ( d?$binary_time )    return d$binary_time;\n"
        "  if ( d?$structure )\n"
        "    {\n"
        "    local parts: vector of string = vector();\n"
        "    for ( i in d$structure )\n"
        "      parts += data_to_str(d$structure[i]);\n"
        "    return fmt(\"[%s]\", join_string_vec(parts, \",\"));\n"
        "    }\n"
        "  if ( d?$array )\n"
        "    {\n"
        "    local parts2: vector of string = vector();\n"
        "    for ( i in d$array )\n"
        "      parts2 += data_to_str(d$array[i]);\n"
        "    return fmt(\"[%s]\", join_string_vec(parts2, \",\"));\n"
        "    }\n"
        "  return \"<unset>\";\n"
        "  }\n\n"
        "event zeek_init()\n"
        "  {\n"
        "  Log::create_stream(MMS_VARS_LOG, [$columns=VarsLog, $path=\"tase2\"]);\n"
        "  }\n\n"
        "# ============== Event-Handler (basierend auf events.zeek) ==============\n"
        "# Read -> Response (Erfolg)\n"
        "event mms::VariableReadResponse(c: connection, name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"read\",\n"
        "       $direction=\"rsp\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $value=data_to_str(data)\n"
        "      ]);\n"
        "    }\n"
        "  }\n\n"
        "# Read -> Response (Fehler)\n"
        "event mms::VariableReadResponseError(c: connection, name: mms::ObjectName, error: mms::DataAccessError)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"read\",\n"
        "       $direction=\"rsp\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $error=fmt(\"%s\", error)\n"
        "      ]);\n"
        "    }\n"
        "  }\n\n"
        "# Write -> Response (Erfolg)\n"
        "event mms::VariableWriteResponse(c: connection, name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"write\",\n"
        "       $direction=\"wrt\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $value=data_to_str(data)\n"
        "      ]);\n"
        "    }\n"
        "  }\n\n"
        "# Write -> Response (Fehler)\n"
        "event mms::VariableWriteResponseError(c: connection, name: mms::ObjectName, data: mms::Data, error: mms::DataAccessError)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"write\",\n"
        "       $direction=\"wrt\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $value=data_to_str(data),\n"
        "       $error=fmt(\"%s\", error)\n"
        "      ]);\n"
        "    }\n"
        "  }\n\n"
        "# Unconfirmed -> InformationReport (Erfolg)\n"
        "event mms::VariableReport(c: connection, name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"report\",\n"
        "       $direction=\"rpt\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $value=data_to_str(data)\n"
        "      ]);\n"
        "    }\n"
        "  }\n\n"
        "# Unconfirmed -> InformationReport (Fehler)\n"
        "event mms::VariableReportError(c: connection, name: mms::ObjectName, error: mms::DataAccessError)\n"
        "  {\n"
        "  local k = obj_name_to_key(name);\n"
        "  if ( k in known_vars )\n"
        "    {\n"
        "    local meta = mms_variables[k];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=\"report\",\n"
        "       $direction=\"rpt\",\n"
        "       $domain=meta$domain,\n"
        "       $name=meta$item,\n"
        "       $obj=k,\n"
        "       $flat_type=meta$flat_type,\n"
        "       $mms_type=meta$mms_type,\n"
        "       $error=fmt(\"%s\", error)\n"
        "      ]);\n"
        "    }\n"
        "  }\n");
}

/* ==================== Error handling ==================== */
static void print_connection_error_and_exit(const char* hostname, int port, MmsError error, MmsConnection connection, const char* what) {
    if (what && *what)
        fprintf(stderr, "Error: %s at MMS server %s:%d.\n", what, hostname, port);
    else
        fprintf(stderr, "Error: Failed to connect to MMS server at %s:%d.\n", hostname, port);

    switch (error) {
        case MMS_ERROR_NONE:
            fprintf(stderr, "  Unknown error: No error reported but operation failed.\n");
            break;
        case MMS_ERROR_CONNECTION_REJECTED:
            fprintf(stderr, "  Reason: Connection was rejected by the remote MMS server.\n");
            break;
        case MMS_ERROR_CONNECTION_LOST:
            fprintf(stderr, "  Reason: Connection was established but then lost unexpectedly.\n");
            break;
        case MMS_ERROR_SERVICE_TIMEOUT:
            fprintf(stderr, "  Reason: Operation timed out while waiting for a response from the server.\n");
            break;
        case MMS_ERROR_PARSING_RESPONSE:
            fprintf(stderr, "  Reason: Failed to parse the server response.\n");
            break;
        case MMS_ERROR_HARDWARE_FAULT:
            fprintf(stderr, "  Reason: A hardware fault occurred (server-side or client-side).\n");
            break;
        case MMS_ERROR_CONCLUDE_REJECTED:
            fprintf(stderr, "  Reason: Server rejected connection conclude operation.\n");
            break;
        case MMS_ERROR_INVALID_ARGUMENTS:
            fprintf(stderr, "  Reason: Invalid arguments provided to connection API.\n");
            break;
        case MMS_ERROR_OUTSTANDING_CALL_LIMIT:
            fprintf(stderr, "  Reason: Outstanding call limit exceeded on the connection.\n");
            break;
        case MMS_ERROR_OTHER:
            fprintf(stderr, "  Reason: Unspecified error occurred during MMS communication.\n");
            break;
        case MMS_ERROR_VMDSTATE_OTHER:
            fprintf(stderr, "  Reason: Error related to remote VMD state.\n");
            break;
        case MMS_ERROR_APPLICATION_REFERENCE_OTHER:
            fprintf(stderr, "  Reason: Application reference problem reported by the server.\n");
            break;
        case MMS_ERROR_DEFINITION_OTHER:
            fprintf(stderr, "  Reason: Problem with MMS definition at the peer.\n");
            break;
        case MMS_ERROR_DEFINITION_INVALID_ADDRESS:
            fprintf(stderr, "  Reason: Invalid address definition in MMS protocol.\n");
            break;
        case MMS_ERROR_DEFINITION_TYPE_UNSUPPORTED:
            fprintf(stderr, "  Reason: Unsupported data type encountered by operation.\n");
            break;
        case MMS_ERROR_DEFINITION_TYPE_INCONSISTENT:
            fprintf(stderr, "  Reason: Inconsistent data type in communication.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_UNDEFINED:
            fprintf(stderr, "  Reason: Requested object is undefined on server.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_EXISTS:
            fprintf(stderr, "  Reason: Requested object already exists on server.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_ATTRIBUTE_INCONSISTENT:
            fprintf(stderr, "  Reason: Inconsistent object attribute definition on server.\n");
            break;
        case MMS_ERROR_RESOURCE_OTHER:
            fprintf(stderr, "  Reason: Resource-related error on server or client.\n");
            break;
        case MMS_ERROR_RESOURCE_CAPABILITY_UNAVAILABLE:
            fprintf(stderr, "  Reason: Required capability is not available on MMS server or client.\n");
            break;
        case MMS_ERROR_SERVICE_OTHER:
            fprintf(stderr, "  Reason: Generic service error occurred during operation.\n");
            break;
        case MMS_ERROR_SERVICE_OBJECT_CONSTRAINT_CONFLICT:
            fprintf(stderr, "  Reason: Object constraint conflict reported by server.\n");
            break;
        case MMS_ERROR_SERVICE_PREEMPT_OTHER:
            fprintf(stderr, "  Reason: Service was preempted by another operation.\n");
            break;
        case MMS_ERROR_TIME_RESOLUTION_OTHER:
            fprintf(stderr, "  Reason: Error with time resolution during operation.\n");
            break;
        case MMS_ERROR_ACCESS_OTHER:
            fprintf(stderr, "  Reason: Generic access error.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_NON_EXISTENT:
            fprintf(stderr, "  Reason: Attempted to access a non-existent object.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_ACCESS_UNSUPPORTED:
            fprintf(stderr, "  Reason: Access to requested object is unsupported by server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_ACCESS_DENIED:
            fprintf(stderr, "  Reason: Access to requested object was denied by server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_INVALIDATED:
            fprintf(stderr, "  Reason: Requested object is invalidated at the server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_VALUE_INVALID:
            fprintf(stderr, "  Reason: Value of the accessed object is invalid.\n");
            break;
        case MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE:
            fprintf(stderr, "  Reason: Access temporarily unavailable. Try again later.\n");
            break;
        case MMS_ERROR_FILE_OTHER:
            fprintf(stderr, "  Reason: Generic file service error during operation.\n");
            break;
        case MMS_ERROR_FILE_FILENAME_AMBIGUOUS:
            fprintf(stderr, "  Reason: Provided filename is ambiguous.\n");
            break;
        case MMS_ERROR_FILE_FILE_BUSY:
            fprintf(stderr, "  Reason: Target file is currently busy and locked by the server.\n");
            break;
        case MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR:
            fprintf(stderr, "  Reason: Syntax error in provided filename.\n");
            break;
        case MMS_ERROR_FILE_CONTENT_TYPE_INVALID:
            fprintf(stderr, "  Reason: Invalid file content type encountered.\n");
            break;
        case MMS_ERROR_FILE_POSITION_INVALID:
            fprintf(stderr, "  Reason: Invalid file position specified.\n");
            break;
        case MMS_ERROR_FILE_FILE_ACCESS_DENIED:
            fprintf(stderr, "  Reason: File access denied by server.\n");
            break;
        case MMS_ERROR_FILE_FILE_NON_EXISTENT:
            fprintf(stderr, "  Reason: Requested file does not exist.\n");
            break;
        case MMS_ERROR_FILE_DUPLICATE_FILENAME:
            fprintf(stderr, "  Reason: Duplicate filename found during operation.\n");
            break;
        case MMS_ERROR_FILE_INSUFFICIENT_SPACE_IN_FILESTORE:
            fprintf(stderr, "  Reason: Insufficient space on the server filestore.\n");
            break;
        case MMS_ERROR_REJECT_OTHER:
            fprintf(stderr, "  Reason: Generic rejection occurred during operation.\n");
            break;
        case MMS_ERROR_REJECT_UNKNOWN_PDU_TYPE:
            fprintf(stderr, "  Reason: Received unknown PDU type from server.\n");
            break;
        case MMS_ERROR_REJECT_INVALID_PDU:
            fprintf(stderr, "  Reason: Received invalid PDU.\n");
            break;
        case MMS_ERROR_REJECT_UNRECOGNIZED_SERVICE:
            fprintf(stderr, "  Reason: Unrecognized service requested/negotiated.\n");
            break;
        case MMS_ERROR_REJECT_UNRECOGNIZED_MODIFIER:
            fprintf(stderr, "  Reason: Unrecognized service modifier in handshake.\n");
            break;
        case MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT:
            fprintf(stderr, "  Reason: Invalid argument found in request.\n");
            break;
        default:
            fprintf(stderr, "  Reason: Unrecognized MMS error code (%d).\n", (int)error);
            break;
    }
    if (connection)
        MmsConnection_destroy(connection);
    exit(EXIT_FAILURE);
}

/* ==================== Type helpers (spec-based) ==================== */

static const char* mms_type_to_string(MmsType t)
{
    switch (t) {
        case MMS_ARRAY:           return "MMS_ARRAY";
        case MMS_STRUCTURE:       return "MMS_STRUCTURE";
        case MMS_BOOLEAN:         return "MMS_BOOLEAN";
        case MMS_BIT_STRING:      return "MMS_BIT_STRING";
        case MMS_INTEGER:         return "MMS_INTEGER";
        case MMS_UNSIGNED:        return "MMS_UNSIGNED";
        case MMS_FLOAT:           return "MMS_FLOAT";
        case MMS_OCTET_STRING:    return "MMS_OCTET_STRING";
        case MMS_VISIBLE_STRING:  return "MMS_VISIBLE_STRING";
        case MMS_GENERALIZED_TIME:return "MMS_GENERALIZED_TIME";
        case MMS_BINARY_TIME:     return "MMS_BINARY_TIME";
        case MMS_BCD:             return "MMS_BCD";
        case MMS_OBJ_ID:          return "MMS_OBJ_ID";
        case MMS_STRING:          return "MMS_STRING";
        case MMS_UTC_TIME:        return "MMS_UTC_TIME";
        default:                  return "UNKNOWN";
    }
}

static const char* flat_type_from_mms_type(MmsType t)
{
    switch (t) {
        case MMS_FLOAT:           return "Real";
        case MMS_INTEGER:         return "Discrete_Or_State";
        case MMS_UNSIGNED:        return "Unsigned";
        case MMS_BOOLEAN:         return "Bool";
        case MMS_VISIBLE_STRING:
        case MMS_STRING:          return "String";
        case MMS_BIT_STRING:      return "Discrete_Or_State";
        default:                  return "unknown";
    }
}

static const char* get_main_mms_type_from_spec(MmsVariableSpecification* spec)
{
    if (!spec) return "UNKNOWN";

    if (spec->type == MMS_STRUCTURE) {
        if (spec->typeSpec.structure.elementCount > 0 && spec->typeSpec.structure.elements) {
            MmsVariableSpecification* e0 = spec->typeSpec.structure.elements[0];
            if (e0) return mms_type_to_string(e0->type);
        }
        return "UNKNOWN";
    }
    else if (spec->type == MMS_ARRAY) {
        if (spec->typeSpec.array.elementTypeSpec)
            return mms_type_to_string(spec->typeSpec.array.elementTypeSpec->type);
        return "UNKNOWN";
    }
    else {
        return mms_type_to_string(spec->type);
    }
}

static const char* tase2_flat_type_from_spec(MmsVariableSpecification* spec)
{
    if (!spec) return "unknown";

    /* If it is a structure/array we infer from first element (similar to value-based logic before) */
    if (spec->type == MMS_STRUCTURE) {
        int n = spec->typeSpec.structure.elementCount;
        if (n > 0 && spec->typeSpec.structure.elements) {
            MmsVariableSpecification* e0 = spec->typeSpec.structure.elements[0];
            if (e0) {
                const char* ft0 = flat_type_from_mms_type(e0->type);
                if (ft0 && strcmp(ft0, "unknown") != 0)
                    return ft0;

                if (n >= 2) {
                    MmsVariableSpecification* e1 = spec->typeSpec.structure.elements[1];
                    if (e0->type == MMS_INTEGER && e1 && e1->type == MMS_BIT_STRING)
                        return "Discrete_Or_State";
                }
            }
        }
        return "unknown";
    }
    else if (spec->type == MMS_ARRAY) {
        if (spec->typeSpec.array.elementTypeSpec)
            return flat_type_from_mms_type(spec->typeSpec.array.elementTypeSpec->type);
        return "unknown";
    }
    else {
        return flat_type_from_mms_type(spec->type);
    }
}

static const char* ignore_vars[] = { "Bilateral_Table_ID", NULL };

static int is_ignored(const char* name) {
    for (int i = 0; ignore_vars[i] != NULL; ++i) {
        if (strcasecmp(name, ignore_vars[i]) == 0)
            return 1;
    }
    return 0;
}

static int hex2int(const char* s)
{
    int val = 0;
    if (!s) return 0;
    if (*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X'))
        s += 2;
    while (*s) {
        char c = *s++;
        if (c >= '0' && c <= '9')
            val = (val << 4) + (c - '0');
        else if (c >= 'a' && c <= 'f')
            val = (val << 4) + (c - 'a' + 10);
        else if (c >= 'A' && c <= 'F')
            val = (val << 4) + (c - 'A' + 10);
        else
            break;
    }
    return val;
}

static void print_help(const char* prog_name) {
    printf("Usage: %s [options] [hostname [port]]\n", prog_name);
    printf("Query an MMS server and print a Zeek script to stdout.\n\n");
    printf("Options:\n");
    printf("  --help                         Print this help message and exit.\n");
    printf("  --password PASSWORD            Set the password for ACSE password authentication.\n");
    printf("  --remote-ap-title STR          Set remote AP-Title (e.g. '1.1.1.999.1').\n");
    printf("  --remote-ae-qualifier N        Set remote AE-Qualifier (e.g. '12').\n");
    printf("  --remote-p-selector HEX        Set remote Presentation-Selector (e.g. '0x00000001').\n");
    printf("  --remote-s-selector HEX        Set remote Session-Selector (e.g. '0x0001').\n");
    printf("  --remote-t-selector HEX        Set remote Transport-Selector (e.g. '0x0001').\n");
    printf("  --local-ap-title STR           Set local AP-Title (e.g. '1.1.1.999').\n");
    printf("  --local-ae-qualifier N         Set local AE-Qualifier (e.g. '12').\n");
    printf("  --local-p-selector HEX         Set local Presentation-Selector (e.g. '0x00000001').\n");
    printf("  --local-s-selector HEX         Set local Session-Selector (e.g. '0x0001').\n");
    printf("  --local-t-selector HEX         Set local Transport-Selector (e.g. '0x0001').\n");
    printf("\n");
    printf("Arguments:\n");
    printf("  hostname      IP address or hostname of the server (default: localhost)\n");
    printf("  tcp port      TCP port to connect (default: 102)\n");
}

int main(int argc, char** argv) {
    char* hostname = NULL;
    int tcpPort = 102;
    char* password = NULL;

    /* ISO Connection Parameter fields */
    char* remote_ap_title = NULL;
    int remote_ae_qualifier = -1;
    int remote_p_selector = -1;
    int remote_s_selector = -1;
    int remote_t_selector = -1;

    char* local_ap_title = NULL;
    int local_ae_qualifier = -1;
    int local_p_selector = -1;
    int local_s_selector = -1;
    int local_t_selector = -1;

    /* Zeek output goes to stdout */
    FILE* zf = stdout;
    int zeek_first_var_entry = 1;
    int zeek_first_known_var = 1;

    /* Defaults */
    const char* default_local_ap_title = "1.1.1.999";
    const int default_local_ae_qualifier = 12;
    const char* default_remote_ap_title = "1.1.1.999.1";
    const int default_remote_ae_qualifier = 12;

    /* Will capture identity and TASE2 version for Zeek header */
    const char* server_vendor = "";
    const char* server_model = "";
    const char* server_revision = "";
    char tase2_version_str[64];
    tase2_version_str[0] = '\0';

    MmsError error;
    int returnCode = 0;

    int argidx = 1;
    while (argidx < argc) {
        if (strcmp(argv[argidx], "--help") == 0) {
            print_help(argv[0]);
            return EXIT_SUCCESS;
        } else if (strcmp(argv[argidx], "--password") == 0) {
            if ((argidx + 1) < argc) {
                password = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "Error: --password requires a value.\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-ap-title") == 0) {
            if ((argidx+1) < argc) {
                remote_ap_title = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-ap-title: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-ae-qualifier") == 0) {
            if ((argidx+1) < argc) {
                remote_ae_qualifier = atoi(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-ae-qualifier: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-p-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_p_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-p-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-s-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_s_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-s-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-t-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_t_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-t-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-ap-title") == 0) {
            if ((argidx+1) < argc) {
                local_ap_title = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "--local-ap-title: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-ae-qualifier") == 0) {
            if ((argidx+1) < argc) {
                local_ae_qualifier = atoi(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-ae-qualifier: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-p-selector") == 0) {
            if ((argidx+1) < argc) {
                local_p_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-p-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-s-selector") == 0) {
            if ((argidx+1) < argc) {
                local_s_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-s-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-t-selector") == 0) {
            if ((argidx+1) < argc) {
                local_t_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-t-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (argv[argidx][0] == '-') {
            fprintf(stderr, "Unknown option: %s\n", argv[argidx]);
            return EXIT_FAILURE;
        } else {
            break;
        }
    }
    if (argidx < argc) {
        hostname = argv[argidx++];
    }
    if (argidx < argc) {
        tcpPort = atoi(argv[argidx]);
        if (tcpPort <= 0 || tcpPort > 65535) {
            fprintf(stderr, "invalid tcp port: %s\n", argv[argidx]);
            return EXIT_FAILURE;
        }
    }
    if (!hostname)
        hostname = (char*)"localhost";

    MmsConnection con = MmsConnection_create();
    IsoConnectionParameters params = MmsConnection_getIsoConnectionParameters(con);

    /* SET ISO CONNECTION PARAMETERS ---------------------------------------- */
    /* Remote AP-Title + AE-Qualifier */
    if (!remote_ap_title) remote_ap_title = (char*)default_remote_ap_title;
    if (remote_ae_qualifier < 0) remote_ae_qualifier = default_remote_ae_qualifier;
    IsoConnectionParameters_setRemoteApTitle(params, remote_ap_title, remote_ae_qualifier);

    /* Local AP-Title + AE-Qualifier */
    if (!local_ap_title) local_ap_title = (char*)default_local_ap_title;
    if (local_ae_qualifier < 0) local_ae_qualifier = default_local_ae_qualifier;
    IsoConnectionParameters_setLocalApTitle(params, local_ap_title, local_ae_qualifier);

    /* Remote Selectors */
    if (remote_p_selector >= 0 || remote_s_selector >= 0 || remote_t_selector >= 0) {
        PSelector psel = {4, {0,0,0,1}};
        SSelector ssel = {2, {0,1}};
        TSelector tsel = {2, {0,1}};
        if (remote_p_selector >= 0) {
            psel.size = 4;
            psel.value[0] = (remote_p_selector >> 24) & 0xFF;
            psel.value[1] = (remote_p_selector >> 16) & 0xFF;
            psel.value[2] = (remote_p_selector >> 8) & 0xFF;
            psel.value[3] = remote_p_selector & 0xFF;
        }
        if (remote_s_selector >= 0) {
            ssel.size = 2;
            ssel.value[0] = (remote_s_selector >> 8) & 0xFF;
            ssel.value[1] = remote_s_selector & 0xFF;
        }
        if (remote_t_selector >= 0) {
            tsel.size = 2;
            tsel.value[0] = (remote_t_selector >> 8) & 0xFF;
            tsel.value[1] = remote_t_selector & 0xFF;
        }
        IsoConnectionParameters_setRemoteAddresses(params, psel, ssel, tsel);
    }

    /* Local Selectors */
    if (local_p_selector >= 0 || local_s_selector >= 0 || local_t_selector >= 0) {
        PSelector psel = {4, {0,0,0,1}};
        SSelector ssel = {2, {0,1}};
        TSelector tsel = {2, {0,1}};
        if (local_p_selector >= 0) {
            psel.size = 4;
            psel.value[0] = (local_p_selector >> 24) & 0xFF;
            psel.value[1] = (local_p_selector >> 16) & 0xFF;
            psel.value[2] = (local_p_selector >> 8) & 0xFF;
            psel.value[3] = local_p_selector & 0xFF;
        }
        if (local_s_selector >= 0) {
            ssel.size = 2;
            ssel.value[0] = (local_s_selector >> 8) & 0xFF;
            ssel.value[1] = local_s_selector & 0xFF;
        }
        if (local_t_selector >= 0) {
            tsel.size = 2;
            tsel.value[0] = (local_t_selector >> 8) & 0xFF;
            tsel.value[1] = local_t_selector & 0xFF;
        }
        IsoConnectionParameters_setLocalAddresses(params, psel, ssel, tsel);
    }
    /* ---------------------------------------- */

    if (password != NULL && strlen(password) > 0) {
        AcseAuthenticationParameter acseParam = AcseAuthenticationParameter_create();
        AcseAuthenticationParameter_setAuthMechanism(acseParam, ACSE_AUTH_PASSWORD);
        AcseAuthenticationParameter_setPassword(acseParam, password);
        IsoConnectionParameters_setAcseAuthenticationParameter(params, acseParam);
    }

    if (!MmsConnection_connect(con, &error, hostname, tcpPort)) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to establish MMS connection");
    }

    /* Server identity: retrieve and capture for Zeek */
    MmsServerIdentity* id = MmsConnection_identify(con, &error);
    if (id != NULL && error == MMS_ERROR_NONE) {
        server_vendor = id->vendorName ? id->vendorName : "";
        server_model = id->modelName ? id->modelName : "";
        server_revision = id->revision ? id->revision : "";
    } else {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve server identity");
    }

    /* TASE2_Version (allowed to read) */
    MmsValue* tase2v = MmsConnection_readVariable(con, &error, NULL, "TASE2_Version");
    if (error != MMS_ERROR_NONE || tase2v == NULL) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Reading variable 'TASE2_Version' failed");
    }

    /* Compute string for Zeek const */
    if (MmsValue_getType(tase2v) == MMS_STRUCTURE && MmsValue_getArraySize(tase2v) == 2) {
        MmsValue* major = MmsValue_getElement(tase2v, 0);
        MmsValue* minor = MmsValue_getElement(tase2v, 1);
        if ((MmsValue_getType(major) == MMS_INTEGER || MmsValue_getType(major) == MMS_UNSIGNED) &&
            (MmsValue_getType(minor) == MMS_INTEGER || MmsValue_getType(minor) == MMS_UNSIGNED)) {
            snprintf(tase2_version_str, sizeof(tase2_version_str), "%lld.%lld",
                     (long long) MmsValue_toInt64(major),
                     (long long) MmsValue_toInt64(minor));
        } else {
            strncpy(tase2_version_str, "unknown", sizeof(tase2_version_str)-1);
            tase2_version_str[sizeof(tase2_version_str)-1] = '\0';
        }
    } else {
        strncpy(tase2_version_str, "unknown", sizeof(tase2_version_str)-1);
        tase2_version_str[sizeof(tase2_version_str)-1] = '\0';
    }
    MmsValue_delete(tase2v);

    /* Write Zeek header to stdout */
    zeek_write_header(zf, server_vendor, server_model, server_revision, tase2_version_str);

    /* Enumerate domains and variables to populate Zeek table (using variable access attributes) */
    LinkedList domains = MmsConnection_getDomainNames(con, &error);
    if (error != MMS_ERROR_NONE || domains == NULL) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve domain-list");
    }

    LinkedList domainElem = LinkedList_getNext(domains);
    while (domainElem != NULL) {
        char* domainName = (char*)domainElem->data;

        LinkedList variables = MmsConnection_getDomainVariableNames(con, &error, domainName);
        if (error != MMS_ERROR_NONE || variables == NULL) {
            print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve variable-list");
        }

        LinkedList varElem = LinkedList_getNext(variables);
        while (varElem != NULL) {
            char* varName = (char*)varElem->data;

            if (!is_ignored(varName)) {
                MmsError localErr = MMS_ERROR_NONE;
                MmsVariableSpecification* spec =
                    MmsConnection_getVariableAccessAttributes(con, &localErr, domainName, varName);
                if (localErr != MMS_ERROR_NONE || spec == NULL) {
                    print_connection_error_and_exit(hostname, tcpPort, localErr, con, "GetVariableAccessAttributes failed");
                }

                const char* ft = tase2_flat_type_from_spec(spec);
                const char* mt = get_main_mms_type_from_spec(spec);
                zeek_write_var_entry(zf, domainName, varName, ft, mt, &zeek_first_var_entry);

                MmsVariableSpecification_destroy(spec);
            }

            varElem = LinkedList_getNext(varElem);
        }
        LinkedList_destroy(variables);

        domainElem = LinkedList_getNext(domainElem);
    }
    LinkedList_destroy(domains);

    /* known_vars head */
    zeek_write_known_vars_head(zf);

    /* Re-enumerate to populate known_vars set */
    LinkedList domains2 = MmsConnection_getDomainNames(con, &error);
    if (error != MMS_ERROR_NONE || domains2 == NULL) {
        fprintf(stderr, "Warning: failed to re-enumerate domains for known_vars: MMS error %d\n", error);
    } else {
        LinkedList domainElem2 = LinkedList_getNext(domains2);
        while (domainElem2 != NULL) {
            char* domainName = (char*)domainElem2->data;

            LinkedList variables2 = MmsConnection_getDomainVariableNames(con, &error, domainName);
            if (error != MMS_ERROR_NONE || variables2 == NULL) {
                fprintf(stderr, "Warning: failed to get variable-list for known_vars in domain %s\n", domainName ? domainName : "(null)");
            } else {
                LinkedList varElem2 = LinkedList_getNext(variables2);
                while (varElem2 != NULL) {
                    char* varName = (char*)varElem2->data;

                    if (!is_ignored(varName)) {
                        zeek_write_known_var(zf, domainName, varName, &zeek_first_known_var);
                    }

                    varElem2 = LinkedList_getNext(varElem2);
                }
                LinkedList_destroy(variables2);
            }

            domainElem2 = LinkedList_getNext(domainElem2);
        }
        LinkedList_destroy(domains2);
    }

    /* Tail (functions + handlers) */
    zeek_write_tail(zf);

cleanup:
    if (con) {
        IsoConnectionParameters params2 = MmsConnection_getIsoConnectionParameters(con);
        if (params2 && password) {
            AcseAuthenticationParameter acseParam = NULL;
            acseParam = params2->acseAuthParameter;
            if (acseParam) {
                AcseAuthenticationParameter_destroy(acseParam);
                params2->acseAuthParameter = NULL;
            }
        }
        MmsConnection_destroy(con);
    }
    return returnCode;
}
