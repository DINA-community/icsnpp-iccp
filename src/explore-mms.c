#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <iec61850_common.h>
#include <mms_client_connection.h>
#include <iso_connection_parameters.h>

#define PROGRAM_VERSION "0.9.3"

static void zeek_fputs_escaped(FILE* f, const char* s)
{
    fputc('"', f);
    for (const unsigned char* p=(const unsigned char*)s; *p; ++p) {
        if (*p == '"' || *p == '\\') {
            fputc('\\', f);
            fputc(*p, f);
        } else if (*p == '\n') {
            fputc('\\', f); fputc('n', f);
        } else if (*p == '\r') {
            fputc('\\', f); fputc('r', f);
        } else if (*p == '\t') {
            fputc('\\', f); fputc('t', f);
        } else {
            fputc(*p, f);
        }
    }
    fputc('"', f);
}

static void zeek_write_header(FILE* zf,
                              const char* vendor,
                              const char* model,
                              const char* revision,
                              const char* tase2_version_str)
{
    fprintf(zf,
        "# THIS FILE IS GENERATED BY explore-mms.\n"
        "# Do not edit manually.\n\n"
        "module tase2;\n\n"
        "export {\n"
        "  redef enum Log::ID += { MMS_VARS_LOG };\n\n"
        "  type VarsLog: record {\n"
        "    ts: time &log;\n"
        "    id: conn_id &log;\n"
        "    uid: string &log &optional;\n"
        "    op: string &log;        # read, write or report\n"
        "    domain: string &log &optional;\n"
        "    name: string &log;\n"
        "    vmd_specific: bool &log;\n"
        "    mms_type: string &log;\n"
        "    value: string &log &optional;\n"
        "    error: string &log &optional;\n"
        "  };\n"
        "}\n\n"
        "# server identity\n"
        "const server_vendor = ");
    zeek_fputs_escaped(zf, vendor ? vendor : "");
    fprintf(zf, ";\nconst server_model = ");
    zeek_fputs_escaped(zf, model ? model : "");
    fprintf(zf, ";\nconst server_revision = ");
    zeek_fputs_escaped(zf, revision ? revision : "");
    fprintf(zf, ";\nconst tase2_version = ");
    zeek_fputs_escaped(zf, tase2_version_str ? tase2_version_str : "");
    fprintf(zf, ";\n\n");

    fprintf(zf,
        "type VarScope: record {\n"
        "  domain: string &optional; # unset if VMD scope\n"
        "  name: string;\n"
        "};\n\n"
        "type VarMeta: record {\n"
        "  mms_type: string;\n"
        "  is_primitive: bool;\n"
        "  value_field: count &optional;\n"
        "};\n\n");

    fprintf(zf, "const mms_variables: table[VarScope] of VarMeta = {\n");
}

static void zeek_write_var_entry(FILE* zf,
                                 const char* domain,
                                 const char* item,
                                 const char* mms_type,
                                 int is_primitive,
                                 int value_field_index,
                                 int* first_entry)
{
    if (!(*first_entry))
        fprintf(zf, ",\n");
    *first_entry = 0;

    fprintf(zf, "  [[");
    if (domain && strcmp(domain, "VMD") != 0) {
        fprintf(zf, "$domain=");
        zeek_fputs_escaped(zf, domain);
        fprintf(zf, ", ");
    }
    fprintf(zf, "$name=");
    zeek_fputs_escaped(zf, item ? item : "");
    fprintf(zf, "]] = [");
    fprintf(zf, "$mms_type=");
    zeek_fputs_escaped(zf, mms_type ? mms_type : "UNKNOWN");
    fprintf(zf, ", $is_primitive=%s", is_primitive ? "T" : "F");
    if (value_field_index >= 0) {
        fprintf(zf, ", $value_field=%d", value_field_index);
    }
    fprintf(zf, "]");
}

static void zeek_write_tail(FILE* zf)
{
    fprintf(zf, "\n};\n\n");

    fprintf(zf, "%s",
        "function data_to_str(d: mms::Data): string\n"
        "  {\n"
        "  if ( d?$integer )        return fmt(\"%d\", d$integer);\n"
        "  if ( d?$unsigned )       return fmt(\"%d\", d$unsigned);\n"
        "  if ( d?$boolean )        return d$boolean ? \"true\" : \"false\";\n"
        "  if ( d?$floating_point ) return d$floating_point;\n"
        "  if ( d?$visible_string ) return d$visible_string;\n"
        "  if ( d?$mMSString )      return d$mMSString;\n"
        "  if ( d?$octet_string )   return d$octet_string;\n"
        "  if ( d?$utc_time )       return d$utc_time;\n"
        "  if ( d?$binary_time )    return d$binary_time;\n"
        "  if ( d?$bit_string )\n"
        "    { local result = \"\"; for ( s in d$bit_string ) result += fmt(\"%02x\", bytestring_to_count(s)); return result; }\n"
        "  if ( d?$structure )\n"
        "    { local parts: vector of string = vector(); for ( i in d$structure ) parts += data_to_str(d$structure[i]); return fmt(\"[%s]\", join_string_vec(parts, \",\")); }\n"
        "  if ( d?$array )\n"
        "    { local parts2: vector of string = vector(); for ( i in d$array ) parts2 += data_to_str(d$array[i]); return fmt(\"[%s]\", join_string_vec(parts2, \",\")); }\n"
        "  return \"<unset>\";\n"
        "  }\n\n"
        "function extract_var_value(data: mms::Data, meta: VarMeta): string\n"
        "  {\n"
        "  return meta$is_primitive ? data_to_str(data)\n"
        "         : (meta?$value_field && |data$structure| > meta$value_field ? data_to_str(data$structure[meta$value_field]) : \"<unset>\");\n"
        "  }\n\n"
        "event zeek_init()\n"
        "  {\n"
        "  Log::create_stream(MMS_VARS_LOG, [$columns=VarsLog, $path=\"tase2\"]);\n"
        "  }\n\n"
        "\n"
        "function log_var_event(c: connection, op: string, domain: string, name: string, data: mms::Data)\n"
        "  {\n"
        "  local s: VarScope;\n"
        "  if ( domain == \"\")\n"
        "    s = [$name=name];\n"
        "  else\n"
        "    s = [$domain=domain, $name=name];\n"
        "  if ( s in mms_variables )\n"
        "    {\n"
        "    local meta = mms_variables[s];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=op,\n"
        "       $domain=domain,\n"
        "       $name=name,\n"
        "       $vmd_specific=domain==\"\",\n"
        "       $mms_type=meta$mms_type,\n"
        "       $value=extract_var_value(data, meta)\n"
        "      ]);\n"
        "    }\n"
        "  }\n"
        "\n"
        "function log_var_error_event(c: connection, op: string, domain: string, name: string, error: any)\n"
        "  {\n"
        "  local s: VarScope;\n"
        "  if ( domain == \"\")\n"
        "    s = [$name=name];\n"
        "  else\n"
        "    s = [$domain=domain, $name=name];\n"
        "  if ( s in mms_variables )\n"
        "    {\n"
        "    local meta = mms_variables[s];\n"
        "    Log::write(MMS_VARS_LOG,\n"
        "      [$ts=network_time(),\n"
        "       $id=c$id,\n"
        "       $uid=c?$uid ? c$uid : \"\",\n"
        "       $op=op,\n"
        "       $domain=domain,\n"
        "       $name=name,\n"
        "       $vmd_specific=domain==\"\",\n"
        "       $mms_type=meta$mms_type,\n"
        "       $error=error\n"
        "      ]);\n"
        "    }\n"
        "  }\n"
        "\n"
        "event mms::VariableReadResponse(c: connection, obj_name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_event(c, \"read\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, data);\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_event(c, \"read\", \"\", obj_name$vmd_specific, data);\n"
        "  }\n\n"
        "event mms::VariableReadResponseError(c: connection, obj_name: mms::ObjectName, error: mms::DataAccessError)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_error_event(c, \"read\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, fmt(\"%s\", error));\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_error_event(c, \"read\", \"\", obj_name$vmd_specific, fmt(\"%s\", error));\n"
        "  }\n\n"
        "event mms::VariableWriteResponse(c: connection, obj_name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_event(c, \"write\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, data);\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_event(c, \"write\", \"\", obj_name$vmd_specific, data);\n"
        "  }\n\n"
        "event mms::VariableWriteResponseError(c: connection, obj_name: mms::ObjectName, data: mms::Data, error: mms::DataAccessError)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_error_event(c, \"write\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, fmt(\"%s\", error));\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_error_event(c, \"write\", \"\", obj_name$vmd_specific, fmt(\"%s\", error));\n"
        "  }\n\n"
        "event mms::VariableReport(c: connection, obj_name: mms::ObjectName, data: mms::Data)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_event(c, \"report\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, data);\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_event(c, \"report\", \"\", obj_name$vmd_specific, data);\n"
        "  }\n\n"
        "event mms::VariableReportError(c: connection, obj_name: mms::ObjectName, error: mms::DataAccessError)\n"
        "  {\n"
        "  if ( obj_name?$domain_specific )\n"
        "      log_var_error_event(c, \"report\", obj_name$domain_specific$domainId, obj_name$domain_specific$itemId, fmt(\"%s\", error));\n"
        "  else if ( obj_name?$vmd_specific )\n"
        "      log_var_error_event(c, \"report\", \"\", obj_name$vmd_specific, fmt(\"%s\", error));\n"
        "  }\n"
    );
}

static void print_connection_error_and_exit(const char* hostname, int port, MmsError error, MmsConnection connection, const char* what) {
    if (what && *what)
        fprintf(stderr, "Error: %s at MMS server %s:%d.\n", what, hostname, port);
    else
        fprintf(stderr, "Error: Failed to connect to MMS server at %s:%d.\n", hostname, port);

    switch (error) {
        case MMS_ERROR_NONE:
            fprintf(stderr, "  Unknown error: No error reported but operation failed.\n");
            break;
        case MMS_ERROR_CONNECTION_REJECTED:
            fprintf(stderr, "  Reason: Connection was rejected by the remote MMS server.\n");
            break;
        case MMS_ERROR_CONNECTION_LOST:
            fprintf(stderr, "  Reason: Connection was established but then lost unexpectedly.\n");
            break;
        case MMS_ERROR_SERVICE_TIMEOUT:
            fprintf(stderr, "  Reason: Operation timed out while waiting for a response from the server.\n");
            break;
        case MMS_ERROR_PARSING_RESPONSE:
            fprintf(stderr, "  Reason: Failed to parse the server response.\n");
            break;
        case MMS_ERROR_HARDWARE_FAULT:
            fprintf(stderr, "  Reason: A hardware fault occurred (server-side or client-side).\n");
            break;
        case MMS_ERROR_CONCLUDE_REJECTED:
            fprintf(stderr, "  Reason: Server rejected connection conclude operation.\n");
            break;
        case MMS_ERROR_INVALID_ARGUMENTS:
            fprintf(stderr, "  Reason: Invalid arguments provided to connection API.\n");
            break;
        case MMS_ERROR_OUTSTANDING_CALL_LIMIT:
            fprintf(stderr, "  Reason: Outstanding call limit exceeded on the connection.\n");
            break;
        case MMS_ERROR_OTHER:
            fprintf(stderr, "  Reason: Unspecified error occurred during MMS communication.\n");
            break;
        case MMS_ERROR_VMDSTATE_OTHER:
            fprintf(stderr, "  Reason: Error related to remote VMD state.\n");
            break;
        case MMS_ERROR_APPLICATION_REFERENCE_OTHER:
            fprintf(stderr, "  Reason: Application reference problem reported by the server.\n");
            break;
        case MMS_ERROR_DEFINITION_OTHER:
            fprintf(stderr, "  Reason: Problem with MMS definition at the peer.\n");
            break;
        case MMS_ERROR_DEFINITION_INVALID_ADDRESS:
            fprintf(stderr, "  Reason: Invalid address definition in MMS protocol.\n");
            break;
        case MMS_ERROR_DEFINITION_TYPE_UNSUPPORTED:
            fprintf(stderr, "  Reason: Unsupported data type encountered by operation.\n");
            break;
        case MMS_ERROR_DEFINITION_TYPE_INCONSISTENT:
            fprintf(stderr, "  Reason: Inconsistent data type in communication.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_UNDEFINED:
            fprintf(stderr, "  Reason: Requested object is undefined on server.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_EXISTS:
            fprintf(stderr, "  Reason: Requested object already exists on server.\n");
            break;
        case MMS_ERROR_DEFINITION_OBJECT_ATTRIBUTE_INCONSISTENT:
            fprintf(stderr, "  Reason: Inconsistent object attribute definition on server.\n");
            break;
        case MMS_ERROR_RESOURCE_OTHER:
            fprintf(stderr, "  Reason: Resource-related error on server or client.\n");
            break;
        case MMS_ERROR_RESOURCE_CAPABILITY_UNAVAILABLE:
            fprintf(stderr, "  Reason: Required capability is not available on MMS server or client.\n");
            break;
        case MMS_ERROR_SERVICE_OTHER:
            fprintf(stderr, "  Reason: Generic service error occurred during operation.\n");
            break;
        case MMS_ERROR_SERVICE_OBJECT_CONSTRAINT_CONFLICT:
            fprintf(stderr, "  Reason: Object constraint conflict reported by server.\n");
            break;
        case MMS_ERROR_SERVICE_PREEMPT_OTHER:
            fprintf(stderr, "  Reason: Service was preempted by another operation.\n");
            break;
        case MMS_ERROR_TIME_RESOLUTION_OTHER:
            fprintf(stderr, "  Reason: Error with time resolution during operation.\n");
            break;
        case MMS_ERROR_ACCESS_OTHER:
            fprintf(stderr, "  Reason: Generic access error.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_NON_EXISTENT:
            fprintf(stderr, "  Reason: Attempted to access a non-existent object.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_ACCESS_UNSUPPORTED:
            fprintf(stderr, "  Reason: Access to requested object is unsupported by server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_ACCESS_DENIED:
            fprintf(stderr, "  Reason: Access to requested object was denied by server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_INVALIDATED:
            fprintf(stderr, "  Reason: Requested object is invalidated at the server.\n");
            break;
        case MMS_ERROR_ACCESS_OBJECT_VALUE_INVALID:
            fprintf(stderr, "  Reason: Value of the accessed object is invalid.\n");
            break;
        case MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE:
            fprintf(stderr, "  Reason: Access temporarily unavailable. Try again later.\n");
            break;
        case MMS_ERROR_FILE_OTHER:
            fprintf(stderr, "  Reason: Generic file service error during operation.\n");
            break;
        case MMS_ERROR_FILE_FILENAME_AMBIGUOUS:
            fprintf(stderr, "  Reason: Provided filename is ambiguous.\n");
            break;
        case MMS_ERROR_FILE_FILE_BUSY:
            fprintf(stderr, "  Reason: Target file is currently busy and locked by the server.\n");
            break;
        case MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR:
            fprintf(stderr, "  Reason: Syntax error in provided filename.\n");
            break;
        case MMS_ERROR_FILE_CONTENT_TYPE_INVALID:
            fprintf(stderr, "  Reason: Invalid file content type encountered.\n");
            break;
        case MMS_ERROR_FILE_POSITION_INVALID:
            fprintf(stderr, "  Reason: Invalid file position specified.\n");
            break;
        case MMS_ERROR_FILE_FILE_ACCESS_DENIED:
            fprintf(stderr, "  Reason: File access denied by server.\n");
            break;
        case MMS_ERROR_FILE_FILE_NON_EXISTENT:
            fprintf(stderr, "  Reason: Requested file does not exist.\n");
            break;
        case MMS_ERROR_FILE_DUPLICATE_FILENAME:
            fprintf(stderr, "  Reason: Duplicate filename found during operation.\n");
            break;
        case MMS_ERROR_FILE_INSUFFICIENT_SPACE_IN_FILESTORE:
            fprintf(stderr, "  Reason: Insufficient space on the server filestore.\n");
            break;
        case MMS_ERROR_REJECT_OTHER:
            fprintf(stderr, "  Reason: Generic rejection occurred during operation.\n");
            break;
        case MMS_ERROR_REJECT_UNKNOWN_PDU_TYPE:
            fprintf(stderr, "  Reason: Received unknown PDU type from server.\n");
            break;
        case MMS_ERROR_REJECT_INVALID_PDU:
            fprintf(stderr, "  Reason: Received invalid PDU.\n");
            break;
        case MMS_ERROR_REJECT_UNRECOGNIZED_SERVICE:
            fprintf(stderr, "  Reason: Unrecognized service requested/negotiated.\n");
            break;
        case MMS_ERROR_REJECT_UNRECOGNIZED_MODIFIER:
            fprintf(stderr, "  Reason: Unrecognized service modifier in handshake.\n");
            break;
        case MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT:
            fprintf(stderr, "  Reason: Invalid argument found in request.\n");
            break;
        default:
            fprintf(stderr, "  Reason: Unrecognized MMS error code (%d).\n", (int)error);
            break;
    }
    if (connection)
        MmsConnection_destroy(connection);
    exit(EXIT_FAILURE);
}

static const char* ignore_vars[] = {
    "TASE2_Version", "Bilateral_Table_ID", "DSTrans", "DSTrans1", "DSTrans2",
    "Next_DSTransfer_Set", "Next_TSTransfer_Set", "Transfer_Set_Name",
     NULL
};

static int is_ignored(const char* name) {
    for (int i = 0; ignore_vars[i] != NULL; ++i) {
        if (strcasecmp(name, ignore_vars[i]) == 0)
            return 1;
    }
    return 0;
}

static const char* mms_type_to_string(MmsType t)
{
    switch (t) {
        case MMS_ARRAY:           return "MMS_ARRAY";
        case MMS_STRUCTURE:       return "MMS_STRUCTURE";
        case MMS_BOOLEAN:         return "MMS_BOOLEAN";
        case MMS_BIT_STRING:      return "MMS_BIT_STRING";
        case MMS_INTEGER:         return "MMS_INTEGER";
        case MMS_UNSIGNED:        return "MMS_UNSIGNED";
        case MMS_FLOAT:           return "MMS_FLOAT";
        case MMS_OCTET_STRING:    return "MMS_OCTET_STRING";
        case MMS_VISIBLE_STRING:  return "MMS_VISIBLE_STRING";
        case MMS_GENERALIZED_TIME:return "MMS_GENERALIZED_TIME";
        case MMS_BINARY_TIME:     return "MMS_BINARY_TIME";
        case MMS_BCD:             return "MMS_BCD";
        case MMS_OBJ_ID:          return "MMS_OBJ_ID";
        case MMS_STRING:          return "MMS_STRING";
        case MMS_UTC_TIME:        return "MMS_UTC_TIME";
        default:                  return "UNKNOWN";
    }
}

static int detect_var_type_custom(
    MmsVariableSpecification* spec,
    char* result_mms_type, size_t result_mms_type_sz,
    int* is_primitive,
    int* value_field_index,
    const char* domain, const char* var)
{
    if (!spec) return 0;
    if (spec->type != MMS_STRUCTURE) {
        snprintf(result_mms_type, result_mms_type_sz, "%s", mms_type_to_string(spec->type));
        *is_primitive = 1;
        *value_field_index = -1;
        return 1;
    }
    for (int i = 0; i < spec->typeSpec.structure.elementCount; ++i) {
        MmsVariableSpecification* elem = spec->typeSpec.structure.elements[i];
        if (!elem || !elem->name) continue;
        if (strcmp(elem->name, "Value") == 0) {
            snprintf(result_mms_type, result_mms_type_sz, "%s", mms_type_to_string(elem->type));
            *is_primitive = 0;
            *value_field_index = i;
            return 1;
        }
    }
    for (int i = 0; i < spec->typeSpec.structure.elementCount; ++i) {
        MmsVariableSpecification* elem = spec->typeSpec.structure.elements[i];
        if (!elem || !elem->name) continue;
        if (strcmp(elem->name, "Flags") == 0) {
            snprintf(result_mms_type, result_mms_type_sz, "%s", mms_type_to_string(elem->type));
            *is_primitive = 0;
            *value_field_index = i;
            return 1;
        }
    }
    fprintf(stderr, "Warning: Variable '%s.%s' is a structure but has neither a member named 'Value' nor 'Flags' -> ignored\n", domain ? domain : "(null)", var ? var : "(null)");
    return 0;
}

static int hex2int(const char* s)
{
    int val = 0;
    if (!s) return 0;
    if (*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X'))
        s += 2;
    while (*s) {
        char c = *s++;
        if (c >= '0' && c <= '9')
            val = (val << 4) + (c - '0');
        else if (c >= 'a' && c <= 'f')
            val = (val << 4) + (c - 'a' + 10);
        else if (c >= 'A' && c <= 'F')
            val = (val << 4) + (c - 'A' + 10);
        else
            break;
    }
    return val;
}

static void print_help(const char* prog_name) {
    printf("Usage: %s [options] [hostname [port]]\n", prog_name);
    printf("Query an MMS server and print a Zeek script to stdout.\n\n");
    printf("Options:\n");
    printf("  --help                         Print this help message and exit.\n");
    printf("  --version                      Print program version and exit.\n");
    printf("  --password PASSWORD            Set the password for ACSE password authentication.\n");
    printf("  --remote-ap-title STR          Set remote AP-Title (e.g. '1.1.1.999.1').\n");
    printf("  --remote-ae-qualifier N        Set remote AE-Qualifier (e.g. '12').\n");
    printf("  --remote-p-selector HEX        Set remote Presentation-Selector (e.g. '0x00000001').\n");
    printf("  --remote-s-selector HEX        Set remote Session-Selector (e.g. '0x0001').\n");
    printf("  --remote-t-selector HEX        Set remote Transport-Selector (e.g. '0x0001').\n");
    printf("  --local-ap-title STR           Set local AP-Title (e.g. '1.1.1.999').\n");
    printf("  --local-ae-qualifier N         Set local AE-Qualifier (e.g. '12').\n");
    printf("  --local-p-selector HEX         Set local Presentation-Selector (e.g. '0x00000001').\n");
    printf("  --local-s-selector HEX         Set local Session-Selector (e.g. '0x0001').\n");
    printf("  --local-t-selector HEX         Set local Transport-Selector (e.g. '0x0001').\n");
    printf("\n");
    printf("Arguments:\n");
    printf("  hostname      IP address or hostname of the server (default: localhost)\n");
    printf("  tcp port      TCP port to connect (default: 102)\n");
}

int main(int argc, char** argv) {
    char* hostname = NULL;
    int tcpPort = 102;
    char* password = NULL;

    char* remote_ap_title = NULL;
    int remote_ae_qualifier = -1;
    int remote_p_selector = -1;
    int remote_s_selector = -1;
    int remote_t_selector = -1;

    char* local_ap_title = NULL;
    int local_ae_qualifier = -1;
    int local_p_selector = -1;
    int local_s_selector = -1;
    int local_t_selector = -1;

    FILE* zf = stdout;
    int zeek_first_var_entry = 1;

    const char* default_local_ap_title = "1.1.1.999";
    const int default_local_ae_qualifier = 12;
    const char* default_remote_ap_title = "1.1.1.999.1";
    const int default_remote_ae_qualifier = 12;

    const char* server_vendor = "";
    const char* server_model = "";
    const char* server_revision = "";
    char tase2_version_str[64];
    tase2_version_str[0] = '\0';

    MmsError error;
    int returnCode = 0;

    int argidx = 1;
    while (argidx < argc) {
        if (strcmp(argv[argidx], "--help") == 0) {
            print_help(argv[0]);
            return EXIT_SUCCESS;
        } else if (strcmp(argv[argidx], "--version") == 0) {
            printf("%s version %s\n", argv[0], PROGRAM_VERSION);
            return EXIT_SUCCESS;
        } else if (strcmp(argv[argidx], "--password") == 0) {
            if ((argidx + 1) < argc) {
                password = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "Error: --password requires a value.\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-ap-title") == 0) {
            if ((argidx+1) < argc) {
                remote_ap_title = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-ap-title: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-ae-qualifier") == 0) {
            if ((argidx+1) < argc) {
                remote_ae_qualifier = atoi(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-ae-qualifier: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-p-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_p_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-p-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-s-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_s_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-s-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--remote-t-selector") == 0) {
            if ((argidx+1) < argc) {
                remote_t_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--remote-t-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-ap-title") == 0) {
            if ((argidx+1) < argc) {
                local_ap_title = argv[argidx + 1];
                argidx += 2;
            } else {
                fprintf(stderr, "--local-ap-title: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-ae-qualifier") == 0) {
            if ((argidx+1) < argc) {
                local_ae_qualifier = atoi(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-ae-qualifier: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-p-selector") == 0) {
            if ((argidx+1) < argc) {
                local_p_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-p-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-s-selector") == 0) {
            if ((argidx+1) < argc) {
                local_s_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-s-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(argv[argidx], "--local-t-selector") == 0) {
            if ((argidx+1) < argc) {
                local_t_selector = hex2int(argv[argidx+1]);
                argidx += 2;
            } else {
                fprintf(stderr, "--local-t-selector: argument required\n");
                return EXIT_FAILURE;
            }
        } else if (argv[argidx][0] == '-') {
            fprintf(stderr, "Unknown option: %s\n", argv[argidx]);
            return EXIT_FAILURE;
        } else {
            break;
        }
    }
    if (argidx < argc) {
        hostname = argv[argidx++];
    }
    if (argidx < argc) {
        tcpPort = atoi(argv[argidx]);
        if (tcpPort <= 0 || tcpPort > 65535) {
            fprintf(stderr, "invalid tcp port: %s\n", argv[argidx]);
            return EXIT_FAILURE;
        }
    }
    if (!hostname)
        hostname = (char*)"localhost";

    MmsConnection con = MmsConnection_create();
    IsoConnectionParameters params = MmsConnection_getIsoConnectionParameters(con);

    if (!remote_ap_title) remote_ap_title = (char*)default_remote_ap_title;
    if (remote_ae_qualifier < 0) remote_ae_qualifier = default_remote_ae_qualifier;
    IsoConnectionParameters_setRemoteApTitle(params, remote_ap_title, remote_ae_qualifier);

    if (!local_ap_title) local_ap_title = (char*)default_local_ap_title;
    if (local_ae_qualifier < 0) local_ae_qualifier = default_local_ae_qualifier;
    IsoConnectionParameters_setLocalApTitle(params, local_ap_title, local_ae_qualifier);

    if (remote_p_selector >= 0 || remote_s_selector >= 0 || remote_t_selector >= 0) {
        PSelector psel = {4, {0,0,0,1}};
        SSelector ssel = {2, {0,1}};
        TSelector tsel = {2, {0,1}};
        if (remote_p_selector >= 0) {
            psel.size = 4;
            psel.value[0] = (remote_p_selector >> 24) & 0xFF;
            psel.value[1] = (remote_p_selector >> 16) & 0xFF;
            psel.value[2] = (remote_p_selector >> 8) & 0xFF;
            psel.value[3] = remote_p_selector & 0xFF;
        }
        if (remote_s_selector >= 0) {
            ssel.size = 2;
            ssel.value[0] = (remote_s_selector >> 8) & 0xFF;
            ssel.value[1] = remote_s_selector & 0xFF;
        }
        if (remote_t_selector >= 0) {
            tsel.size = 2;
            tsel.value[0] = (remote_t_selector >> 8) & 0xFF;
            tsel.value[1] = remote_t_selector & 0xFF;
        }
        IsoConnectionParameters_setRemoteAddresses(params, psel, ssel, tsel);
    }

    if (local_p_selector >= 0 || local_s_selector >= 0 || local_t_selector >= 0) {
        PSelector psel = {4, {0,0,0,1}};
        SSelector ssel = {2, {0,1}};
        TSelector tsel = {2, {0,1}};
        if (local_p_selector >= 0) {
            psel.size = 4;
            psel.value[0] = (local_p_selector >> 24) & 0xFF;
            psel.value[1] = (local_p_selector >> 16) & 0xFF;
            psel.value[2] = (local_p_selector >> 8) & 0xFF;
            psel.value[3] = local_p_selector & 0xFF;
        }
        if (local_s_selector >= 0) {
            ssel.size = 2;
            ssel.value[0] = (local_s_selector >> 8) & 0xFF;
            ssel.value[1] = local_s_selector & 0xFF;
        }
        if (local_t_selector >= 0) {
            tsel.size = 2;
            tsel.value[0] = (local_t_selector >> 8) & 0xFF;
            tsel.value[1] = local_t_selector & 0xFF;
        }
        IsoConnectionParameters_setLocalAddresses(params, psel, ssel, tsel);
    }

    if (password != NULL && strlen(password) > 0) {
        AcseAuthenticationParameter acseParam = AcseAuthenticationParameter_create();
        AcseAuthenticationParameter_setAuthMechanism(acseParam, ACSE_AUTH_PASSWORD);
        AcseAuthenticationParameter_setPassword(acseParam, password);
        IsoConnectionParameters_setAcseAuthenticationParameter(params, acseParam);
    }

    if (!MmsConnection_connect(con, &error, hostname, tcpPort)) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to establish MMS connection");
    }

    MmsServerIdentity* id = MmsConnection_identify(con, &error);
    if (id != NULL && error == MMS_ERROR_NONE) {
        server_vendor = id->vendorName ? id->vendorName : "";
        server_model = id->modelName ? id->modelName : "";
        server_revision = id->revision ? id->revision : "";
    } else {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve server identity");
    }

    MmsValue* tase2v = MmsConnection_readVariable(con, &error, NULL, "TASE2_Version");
    if (error != MMS_ERROR_NONE || tase2v == NULL) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Reading variable 'TASE2_Version' failed");
    }
    if (MmsValue_getType(tase2v) == MMS_STRUCTURE && MmsValue_getArraySize(tase2v) == 2) {
        MmsValue* major = MmsValue_getElement(tase2v, 0);
        MmsValue* minor = MmsValue_getElement(tase2v, 1);
        if ((MmsValue_getType(major) == MMS_INTEGER || MmsValue_getType(major) == MMS_UNSIGNED) &&
            (MmsValue_getType(minor) == MMS_INTEGER || MmsValue_getType(minor) == MMS_UNSIGNED)) {
            snprintf(tase2_version_str, sizeof(tase2_version_str), "%lld.%lld",
                     (long long) MmsValue_toInt64(major),
                     (long long) MmsValue_toInt64(minor));
        } else {
            strncpy(tase2_version_str, "unknown", sizeof(tase2_version_str)-1);
            tase2_version_str[sizeof(tase2_version_str)-1] = '\0';
        }
    } else {
        strncpy(tase2_version_str, "unknown", sizeof(tase2_version_str)-1);
        tase2_version_str[sizeof(tase2_version_str)-1] = '\0';
    }
    MmsValue_delete(tase2v);

    zeek_write_header(zf, server_vendor, server_model, server_revision, tase2_version_str);

    LinkedList domains = MmsConnection_getDomainNames(con, &error);
    if (error != MMS_ERROR_NONE || domains == NULL) {
        print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve domain-list");
    }
    LinkedList domainElem = LinkedList_getNext(domains);
    while (domainElem != NULL) {
        char* domainName = (char*)domainElem->data;
        LinkedList variables = MmsConnection_getDomainVariableNames(con, &error, domainName);
        if (error != MMS_ERROR_NONE || variables == NULL) {
            print_connection_error_and_exit(hostname, tcpPort, error, con, "Failed to retrieve variable-list");
        }
        LinkedList varElem = LinkedList_getNext(variables);
        while (varElem != NULL) {
            char* varName = (char*)varElem->data;
            if (!is_ignored(varName)) {
                MmsError localErr = MMS_ERROR_NONE;
                MmsVariableSpecification* spec =
                    MmsConnection_getVariableAccessAttributes(con, &localErr, domainName, varName);
                if (localErr != MMS_ERROR_NONE || spec == NULL) {
                    print_connection_error_and_exit(hostname, tcpPort, localErr, con, "GetVariableAccessAttributes failed");
                }
                char mms_type[64];
                int is_primitive = 0;
                int value_field_index = -1;
                if (detect_var_type_custom(spec, mms_type, sizeof(mms_type), &is_primitive, &value_field_index, domainName, varName)) {
                    zeek_write_var_entry(zf, domainName, varName, mms_type, is_primitive, value_field_index, &zeek_first_var_entry);
                }
                MmsVariableSpecification_destroy(spec);
            }
            varElem = LinkedList_getNext(varElem);
        }
        LinkedList_destroy(variables);
        domainElem = LinkedList_getNext(domainElem);
    }
    LinkedList_destroy(domains);

    LinkedList vmd_vars = MmsConnection_getVMDVariableNames(con, &error);
    if (error == MMS_ERROR_NONE && vmd_vars != NULL) {
        LinkedList vmdVarElem = LinkedList_getNext(vmd_vars);
        while (vmdVarElem != NULL) {
            char* varName = (char*)vmdVarElem->data;
            if (!is_ignored(varName)) {
                MmsError localErr = MMS_ERROR_NONE;
                MmsVariableSpecification* spec =
                    MmsConnection_getVariableAccessAttributes(con, &localErr, NULL, varName);
                if (localErr != MMS_ERROR_NONE || spec == NULL) {
                    print_connection_error_and_exit(hostname, tcpPort, localErr, con, "GetVariableAccessAttributes for VMD failed");
                }
                char mms_type[64];
                int is_primitive = 0;
                int value_field_index = -1;
                if (detect_var_type_custom(spec, mms_type, sizeof(mms_type), &is_primitive, &value_field_index, NULL, varName)) {
                    zeek_write_var_entry(zf, NULL, varName, mms_type, is_primitive, value_field_index, &zeek_first_var_entry);
                }
                MmsVariableSpecification_destroy(spec);
            }
            vmdVarElem = LinkedList_getNext(vmdVarElem);
        }
        LinkedList_destroy(vmd_vars);
    }

    zeek_write_tail(zf);

cleanup:
    if (con) {
        IsoConnectionParameters params2 = MmsConnection_getIsoConnectionParameters(con);
        if (params2 && password) {
            AcseAuthenticationParameter acseParam = NULL;
            acseParam = params2->acseAuthParameter;
            if (acseParam) {
                AcseAuthenticationParameter_destroy(acseParam);
                params2->acseAuthParameter = NULL;
            }
        }
        MmsConnection_destroy(con);
    }
    return returnCode;
}
